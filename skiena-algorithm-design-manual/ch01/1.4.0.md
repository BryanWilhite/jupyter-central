## Modeling the Problem

The first call to action to study the history of algorithms was in 1.3.2 in order to help us develop a vocabulary for problem statements. This section has the second call to action for respecting historical precedent to avoid reinventing the wheel.

>To exploit the algorithms literature, you must learn to describe your problem abstractly, in terms of procedures on fundamental structures.

The _procedures_ Skiena highlights are:

* combinatorial (see [1.4.1](./1.4.1.md))
* recursive (see [1.4.2](./1.4.2.md))

These procedures led to the development of “fundamental structures” or “objects” under the umbrella of _[data structures](https://en.wikipedia.org/wiki/Data_structure)_. (Or, perhaps, this could be other way round: a data structure led to a procedure.) The [list of data structures](https://en.wikipedia.org/wiki/List_of_data_structures) is quite substantial. There is even a [Dictionary of Algorithms and Data Structures](https://xlinux.nist.gov/dads/), serving as a table of contents of sorts for “algorithms literature.” The second half of Skiena’s book has _A Catalog of Algorithmic Problems_, upwards of 300 pages of algorithms! He also has [a web page](http://algorist.com/algorist.html) with “a comprehensive collection of algorithm implementations for seventy-five of the most fundamental problems in combinatorial algorithms.”

It has been said that a “good” programmer is not distinguished by rote memorization but rather how well she can look things up. We can see here that we are ultimately talking about researching “algorithms literature,” going well beyond what is usually found on [StackOverflow.com](https://stackoverflow.com/).

One way to automate distinguishing among data structures is to have the notion of a _[type](https://en.wikipedia.org/wiki/List_of_data_structures#Data_types)_ which leads to the subject of _type theory_ part of the “holy trinity” of computer science (see [1.3.0](./1.3.0.md)).